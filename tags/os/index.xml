<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Os on Jinkyu Koo</title>
    <link>https://helix979.github.io/jkoo/tags/os/index.xml</link>
    <description>Recent content in Os on Jinkyu Koo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Jinkyu Koo</copyright>
    <atom:link href="/jkoo/tags/os/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Linux kernel scheduler</title>
      <link>https://helix979.github.io/jkoo/post/os-scheduler/</link>
      <pubDate>Mon, 05 Jan 2015 11:00:00 +0000</pubDate>
      
      <guid>https://helix979.github.io/jkoo/post/os-scheduler/</guid>
      <description>

&lt;h3 id=&#34;what-is-the-kernel&#34;&gt;What is the kernel?&lt;/h3&gt;

&lt;p&gt;The kernel is fundamental part of an operating system (OS) that manages
the computer’s hardwares, and allows softwares to run and use hardware
resources in shared manners. Typically, the hardware resources to take
into account are: (1) processors, (2) memory, and (3) input/output (I/O)
devices such as keyboard, disk drives, network interface cards, and so
on.&lt;/p&gt;

&lt;p&gt;Rough distinction between an OS and a kernel is that an OS is the kernel
plus some useful utilities and applications such as administration tools
and GUIs.&lt;/p&gt;

&lt;h3 id=&#34;monolithic-kernels-and-modules&#34;&gt;Monolithic kernels and modules&lt;/h3&gt;

&lt;p&gt;Linux has a monolithic kernel that contains all of the code necessary to
perform every kernel related task in a single binary file. However,
Linux can extend its functionality by adding modules. Here, the modules
are pieces of code that can be loaded and unloaded into the kernel upon
demand while a system is up and running.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;process&#34;&gt;Process&lt;/h1&gt;

&lt;p&gt;A process is an instance of a computer program that is being executed.
Each process has its own address space, which is protected from being
accessed by other processes except through a legitimate means, that is,
an inter-process communication mechanism.&lt;/p&gt;

&lt;p&gt;The address space is typically partitioned into several regions: text, data, bss, heap and stack. The
text segment contains the compiled code of a program, &lt;em&gt;i.e.&lt;/em&gt;, a set of
instructions. The data segment stores initialized global and static
variables, and constant variables like strings. The uninitialized global
and static variables are located in the bss segment. The heap is the
region set aside for dynamic memory allocation. The stack is where local
variables are allocated within functions.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://helix979.github.io/jkoo/img/address_space.PNG&#34; alt=&#34;No sharing between processes; threads within a process share text, data, bss.&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Address spaces.&lt;/h4&gt;
        &lt;p&gt;
        No sharing between processes; threads within a process share text, data, bss.
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;A thread is also the programmed code in execution. The thread is the
smallest unit that can be managed independently by a kernel scheduler.
However, unlike a process, the thread runs inside the address space of a
process that it belongs to (refer to Figure 1.)
Multiple threads can exist within the same process and share memory.
Thanks to the shared memory, threads can easily communicate with one
another. Although each thread has a separate stack for local variables
and function calls, the stacks are allocated from the shared data area
in the process’ address space.&lt;/p&gt;

&lt;p&gt;In Linux kernel terms, a thread is often called a task. In the meantime,
since by default Linux kernel creates a process with a single thread by
which actual work of the process is done, a thread may look like a
process. For that reason, we sometimes refer to a process as a task as
well.&lt;/p&gt;

&lt;h3 id=&#34;creating-a-new-process-fork-and-exec&#34;&gt;Creating a new process: fork() and exec()&lt;/h3&gt;

&lt;p&gt;Linux kernel generates a new process using &lt;code&gt;fork()&lt;/code&gt; system call directly
followed by &lt;code&gt;exec()&lt;/code&gt; system call.&lt;/p&gt;

&lt;p&gt;When a process invokes &lt;code&gt;fork()&lt;/code&gt;, a separate address space is created for
a new process (called a child process), and all the memory segments of
the original process (called a parent process) are copied into there. As
a result, both the parent and the child have the exact same content in
their own address space. The &lt;code&gt;fork()&lt;/code&gt; returns the process ID (PID) of a
new child process to the parent process, and returns zero to the child
process.&lt;/p&gt;

&lt;p&gt;When the child process calls &lt;code&gt;exec()&lt;/code&gt;, all data in the original program
is replaced with a running copy of the new program. In other words,
&lt;code&gt;exec()&lt;/code&gt; replaces the current process with a new process of an
executable binary file specified in its arguments.&lt;/p&gt;

&lt;h3 id=&#34;waiting-until-a-child-process-terminates&#34;&gt;Waiting until a child process terminates&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;wait()&lt;/code&gt; system call allows the parent process to halt execution
until its child process finishes. A call to &lt;code&gt;wait()&lt;/code&gt; returns the PID of
the child process on success.&lt;/p&gt;

&lt;h3 id=&#34;zombie-processes&#34;&gt;Zombie processes&lt;/h3&gt;

&lt;p&gt;When a child process terminates, it still exists as an entry in the
process table. This entry is required until the parent process reads its
child’s exit status by calling &lt;code&gt;wait()&lt;/code&gt; system call, which then removes
the entry from the process table.&lt;/p&gt;

&lt;p&gt;Thus, the ended child process becomes a meaningless process and just
remains until the parent process terminates or it calls &lt;code&gt;wait()&lt;/code&gt;. The
process in this defunct state is called the zombie process.&lt;/p&gt;

&lt;h3 id=&#34;copy-on-write&#34;&gt;Copy-on-write&lt;/h3&gt;

&lt;p&gt;A naive approach to implement &lt;code&gt;fork()&lt;/code&gt; is that when &lt;code&gt;fork()&lt;/code&gt; is called,
the kernel literally makes the copies of all the data belonging to the
parent process, and puts them into the address space for the child
process. This is inefficient in that although it takes too much time to
duplicate the data, the child may not use any of them in certain cases.
For example, if the child issues &lt;code&gt;exec()&lt;/code&gt; right after &lt;code&gt;fork()&lt;/code&gt;, all the
effort to copy becomes wasteful. Even when the data is indeed used in
the child, read-only data can just be shared by having pointers without
burdensome copying jobs.&lt;/p&gt;

&lt;p&gt;To avoid such inefficiency, the Linux kernel uses what is called the
copy-on-write to implement &lt;code&gt;fork()&lt;/code&gt;. The copy-on-write is a technique by
which copying involved in &lt;code&gt;fork()&lt;/code&gt; occurs only when either the parent or
the child writes. Instead of duplicating all the data upon &lt;code&gt;fork()&lt;/code&gt;, the
parent and the child share the data, marking them to be read-only. When
some page (the smallest unit of data for memory management) is modified
by any of the two processes, a page fault occurs, which makes each
process get a unique copy of the page marked read-write.&lt;/p&gt;

&lt;h3 id=&#34;pid-tid-ppid-and-tgid&#34;&gt;PID, TID, PPID, and TGID&lt;/h3&gt;

&lt;p&gt;The smallest scheduling entity in the Linux kernel is a thread, not a
process. Each thread is assigned a unique number for this purpose. In
the kernel terms, confusingly enough, this number is called a process ID
(PID). The process that threads belong to is accounted for as the thread
group ID (TGID).&lt;/p&gt;

&lt;p&gt;When a new process starts by invoking &lt;code&gt;fork()&lt;/code&gt;, it is assigned a new
TGID. This newly forked process is created with a single thread, whose
PID is the same as the TGID. The parent’s TGID is called a parent PID
(PPID). If the thread creates another thread, the new thread gets a
different PID, but the same TGID is taken over.&lt;/p&gt;

&lt;p&gt;In the mean time, some user space applications (&lt;em&gt;e.g.&lt;/em&gt;, &lt;code&gt;ps&lt;/code&gt;) have a
different (probably better) naming convention: the PID and the TGID in
kernel-space view are, respectively, called a thread ID (TID) and a PID
in these userland applications. Figure 2 summarizes the
relationship among these IDs.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://helix979.github.io/jkoo/img/pid.PNG&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Relationship among PID, TID, PPID, and TGID.&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;scheduler&#34;&gt;Scheduler&lt;/h1&gt;

&lt;h3 id=&#34;what-the-scheduler-does&#34;&gt;What the scheduler does&lt;/h3&gt;

&lt;p&gt;In modern computer systems, there may be many threads waiting to be
served at the same time. Thus, one of the most important jobs of the
kernel is to decide which thread to run for how long. The part of the
kernel in charge of this business is called the scheduler.&lt;/p&gt;

&lt;p&gt;On a single processor system, the scheduler alternates different threads
in a time-division manner, which may lead to the illusion of multiple
threads running concurrently. On a multi-processor system, the scheduler
assigns a thread at each processor so that the threads can be truly
concurrent.&lt;/p&gt;

&lt;h3 id=&#34;priority&#34;&gt;Priority&lt;/h3&gt;

&lt;p&gt;Most of scheduling algorithms are priority-based. A thread is assigned a
priority according to its importance and need for processor time. The
general idea, which isn’t exactly implemented on Linux, is that threads
with a higher priority run before those with a lower priority, whereas
threads with the same priority are scheduled in a round-robin fashion.&lt;/p&gt;

&lt;h3 id=&#34;preemptive-scheduling&#34;&gt;Preemptive scheduling&lt;/h3&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://helix979.github.io/jkoo/img/preemption.PNG&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Preemption.&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Linux kernel features a preemptive scheduling, which means that a thread
can stop to execute another thread before it completes as shown in
Figure 3. A thread can be preempted by a pending thread
that is more important (&lt;em&gt;e.g.&lt;/em&gt;, of a higher priority). The preempted
thread resumes its execution after the preempting thread finishes or
blocks.&lt;/p&gt;

&lt;h3 id=&#34;context-switching&#34;&gt;Context switching&lt;/h3&gt;

&lt;p&gt;All information that describes the states of the currently running
thread is referred to as the “context&amp;rdquo;. The context of a thread are
mainly the contents of hardware registers including the program counter,
the address space, and memory map (which will be explained later).
Simply put, the context tells up to what point the instructions of the
thread is executed, what the outcomes is, and where the content of
memory pertinent to the thread exist. These are all you need to know in
order to resume the thread at a later time.&lt;/p&gt;

&lt;p&gt;When a processor changes a thread to execute from one to another (as a
result of scheduling for instance), the context of the old thread is
saved somewhere, and the context of the new thread gets loaded. This
procedure is called the context switching. The context switching happens
fast and frequently enough that the users feel like the threads are
running at the same time.&lt;/p&gt;

&lt;h3 id=&#34;thread-states&#34;&gt;Thread states&lt;/h3&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://helix979.github.io/jkoo/img/state.PNG&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Thread states.&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;The scheduler needs to know which threads are runnable at a given time
so that it can choose a right one to run next. For that reason, each
thread maintains its current state. In general terms, a thread may stay
in one out of the following states (see also Figure 4).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Ready: The thread is ready to run, but not allowed to, because all
processors are busy executing other threads. The ready thread is
awaiting execution until the scheduler chooses itself to run next.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Running: Instructions of the thread are being executed on a
processor.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Blocked: The thread is blocked waiting for some external event such
as I/O or a signal. The blocked thread is not a candidate to
schedule, &lt;em&gt;i.e.&lt;/em&gt;, it cannot run.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;io-bound-vs.-cpu-bound&#34;&gt;I/O-bound vs. CPU-bound&lt;/h3&gt;

&lt;p&gt;Threads (or processes) can be classified into two major types: I/O-bound
and CPU-bound.&lt;/p&gt;

&lt;p&gt;The I/O-bound threads are mostly waiting for arrivals of inputs (&lt;em&gt;e.g.&lt;/em&gt;,
keyboard strokes) or the completion of outputs (&lt;em&gt;e.g.&lt;/em&gt;, writing into
disks). In general, these threads do not stay running for very long, and
block themselves voluntarily to wait for I/O events. What matters with
the I/O-bound threads is that they need to be processed in quick, since
otherwise users may feel that the system has no good responsiveness.
Therefore, a common rule is that a scheduler puts more urgency into
serving the I/O-bound threads.&lt;/p&gt;

&lt;p&gt;The CPU-bound threads are ones that spend much of their time in doing
calculations (&lt;em&gt;e.g.&lt;/em&gt;, compiling a program). Since there are not many I/O
events involved, they tend to run as long as the scheduler allows.
Typically, users do not expect the system to be responsive while the
CPU-bound threads are running. Thus, the CPU-bound threads are picked to
run by a scheduler less frequently. However, once chosen, they holds a
CPU for a longer time.&lt;/p&gt;

&lt;h3 id=&#34;real-time-vs.-non-real-time&#34;&gt;Real-time vs. non-real-time&lt;/h3&gt;

&lt;p&gt;Another criterion that categorizes threads is if they are real-time
threads or not.&lt;/p&gt;

&lt;p&gt;The real-time threads are ones that should be processed with a strict
time constraint, often referred to as a deadline. The operational
correctness of a real-time thread depends not only on computation
results, but also on whether the results are produced before the
deadline. Therefore, the scheduler, in general, takes care of the
real-time threads with a high priority.&lt;/p&gt;

&lt;p&gt;Real-time threads can be further classified into hard real-time or soft
real-time ones by the consequence of missing a deadline. Hard real-time
threads require all deadlines to be met with no exception; otherwise, a
system may fall into catastrophic failure. For the soft real-time
threads, missing a deadline results in degraded quality for the intended
service, but a system can still go on.&lt;/p&gt;

&lt;p&gt;Non-real-time threads are not associated with any deadlines. They could
be human-interactive threads or batch threads. Here, the batch threads
are ones that process a large amount of data without manual
intervention. For the batch threads, a fast response time is not
critical, and so they can be scheduled to run as resources allow.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;core-scheduler&#34;&gt;Core Scheduler&lt;/h2&gt;

&lt;h3 id=&#34;scheduling-classes&#34;&gt;Scheduling classes&lt;/h3&gt;

&lt;p&gt;One may say that the Linux kernel scheduler consists of mainly two
different scheduling algorithms, which are what are called the real-time
scheduler and the completely fair scheduler. Scheduling classes allow
for implementing these algorithms in a modular way. In detail, a
scheduling class is a set of function pointers, defined through
&lt;code&gt;struct sched_class&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct sched_class {
    const struct sched_class *next;
    ...
    struct task_struct * (*pick_next_task) (struct rq *rq, struct task_struct *prev);
    void (*put_prev_task) (struct rq *rq, struct task_struct *p);
    ...
    void (*task_tick) (struct rq *rq, struct task_struct *p, int queued);
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each scheduling algorithm gets an instance of
&lt;code&gt;struct sched_class&lt;/code&gt; and connects the function pointers with their
corresponding implementations.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;rt_sched_class&lt;/code&gt; implements so-called real-time (RT) scheduler.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const struct sched_class rt_sched_class = {
    .next           = &amp;amp;fair_sched_class,
    ...
    .pick_next_task     = pick_next_task_rt,
    .put_prev_task      = put_prev_task_rt,
    ...
    .task_tick      = task_tick_rt,
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As its name implies, the RT scheduler targets to deals with the real-time
threads. The RT scheduler assigns a priority to every thread to
schedule, and processes the threads in order of their priorities. The RT
scheduler is proved good enough by many people’s experience, but there
is no guarantee that all deadlines are met. Namely, the RT scheduler in
the Linux kernel only addresses the needs of threads with soft real-time
requirements.&lt;/p&gt;

&lt;p&gt;The completely fair scheduler (CFS) is implemented by the
&lt;code&gt;fair_sched_class&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const struct sched_class fair_sched_class = {
    .next           = &amp;amp;idle_sched_class,
    ...
    .pick_next_task     = pick_next_task_fair,
    .put_prev_task      = put_prev_task_fair,
    ...
    .task_tick      = task_tick_fair,
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The CFS also assigns a priority to a thread.
However, unlike in the RT scheduler, this priority does not directly
mean the order of being processed. Rather, it decides how long a thread
can occupies a processor compared to others. In other words, the
priority in CFS determines the proportion of processor time that a
thread can use. Threads with a high priority can hold a processor longer
than threads with a low priority. Meanwhile, the CFS may allow a
long-waited low-priority thread to run even though there are
high-priority threads ready. This is because each thread is guaranteed
to use its own fraction of processor time for a certain time interval
according to its priority, which is why the term “fair&amp;rdquo; comes in the
name of this scheduling algorithm.&lt;/p&gt;

&lt;p&gt;The core logics of the kernel scheduler iterate over scheduler classes
in order of their priority: &lt;code&gt;rt_sched_class&lt;/code&gt; processed prior to
&lt;code&gt;fair_sched_class&lt;/code&gt;. That way, codes in the &lt;code&gt;rt_sched_class&lt;/code&gt; does not
need to interact with codes in the &lt;code&gt;fair_sched_class&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;scheduling-policies&#34;&gt;Scheduling policies&lt;/h3&gt;

&lt;p&gt;When created, each thread gets assigned a scheduling policy that is in
turn treated by a specific scheduling algorithm. Different scheduling
policies may result in different outcomes even with the same scheduling
algorithm.&lt;/p&gt;

&lt;p&gt;The RT scheduler supports the following two scheduling policies:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;SCHED_RR&lt;/code&gt;: Threads of this type run one by one for a pre-defined
time interval in their turn (round robin).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;SCHED_FIFO&lt;/code&gt;: Threads of this type run until done once selected
(first-in/first-out).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The scheduling polices dealt with by the CFS include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;SCHED_BATCH&lt;/code&gt;: This policy handles the threads that have a
batch-characteristic, &lt;em&gt;i.e.&lt;/em&gt;, CPU-bounded and non-interactive.
Threads of this type never preempt non-idle threads.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;SCHED_NORMAL&lt;/code&gt;: Normal threads fall into this type.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;run-queues&#34;&gt;Run queues&lt;/h3&gt;

&lt;p&gt;The core scheduler manages ready threads by enqueueing them into a run
queue, which is implemented by &lt;code&gt;struct rq&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct rq {
    ...
    struct cfs_rq cfs;
    struct rt_rq rt;
    ...
    struct task_struct *curr, *idle, *stop;
    ...
    u64 clock;
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each CPU has its own run queue, &lt;em&gt;i.e.&lt;/em&gt;, there are as many run queues as the number of CPUs in a
system. A ready thread can belong to a single run queue at a time, since
it is impossible that multiple CPUs process the same thread
simultaneously. Here comes the need of load balancing among CPUs in
multi-core systems. Without a special effort to balance load, threads
may wait in a specific CPU’s run queue, while other CPUs have nothing in
their run queue, which, of course, means performance degradation.&lt;/p&gt;

&lt;p&gt;A run queue includes &lt;code&gt;struct cfs_rq cfs&lt;/code&gt; and &lt;code&gt;struct rt_rq rt&lt;/code&gt;, which
are sub-run queues for the CFS and the RT scheduler, respectively.
Enqueueing a thread into a run queue eventually means enqueueing it into
either of these sub-run queues depending on the scheduler class of the
thread. The thread that is currently running on a CPU is pointed by
&lt;code&gt;struct task_struct *curr&lt;/code&gt; defined in the run queue of the CPU. The
per-run queue variable &lt;code&gt;clock&lt;/code&gt; is used to store the latest time at which
the corresponding CPU reads a clock source.&lt;/p&gt;

&lt;h3 id=&#34;the-main-body-__schedule&#34;&gt;The main body: &lt;code&gt;__schedule()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The function &lt;code&gt;__schedule()&lt;/code&gt; is the main body of the core scheduler. What
it does includes putting the previously running thread into a run queue,
picking a new thread to run next, and lastly switching context between
the two threads.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void __sched __schedule(void)
{
    ...
    cpu = smp_processor_id();
    rq = cpu_rq(cpu);
    prev = rq-&amp;gt;curr;
    ...
    put_prev_task(rq, prev);
    ...
    next = pick_next_task(rq);
    ...
    if (likely(prev != next)) {
        ...
        rq-&amp;gt;curr = next;
        ...
        context_switch(rq, prev, next);
        ...
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most work in &lt;code&gt;__schedule()&lt;/code&gt; is delegated to the scheduling classes. For
example, when &lt;code&gt;put_prev_task()&lt;/code&gt; is invoked in &lt;code&gt;__schedule()&lt;/code&gt;, actual
work is done by the function registered to the function pointer
&lt;code&gt;put_prev_task&lt;/code&gt; of the scheduling class that the previously running task
belongs to.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void put_prev_task(struct rq *rq, struct task_struct *prev)
{
    ...
    prev-&amp;gt;sched_class-&amp;gt;put_prev_task(rq, prev);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As shown in &lt;code&gt;rt_sched_class&lt;/code&gt; and &lt;code&gt;fair_sched_class&lt;/code&gt;, this is &lt;code&gt;put_prev_task_rt()&lt;/code&gt; for the RT
scheduler and &lt;code&gt;put_prev_task_fair()&lt;/code&gt; for the CFS. A similar thing
applies when &lt;code&gt;pick_next_task()&lt;/code&gt; is invoked.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define for_each_class(class) \
   for (class = sched_class_highest; class; class = class-&amp;gt;next)

static inline struct task_struct *pick_next_task(struct rq *rq)
{
    const struct sched_class *class;
    struct task_struct *p;
    ...
    for_each_class(class) {
        p = class-&amp;gt;pick_next_task(rq);
        if (p)
            return p;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function
&lt;code&gt;pick_next_task()&lt;/code&gt; seeks the next-running thread using the function
pointer &lt;code&gt;pick_next_task&lt;/code&gt; of a scheduling class by which
&lt;code&gt;pick_next_task_fair()&lt;/code&gt; and &lt;code&gt;pick_next_task_rt()&lt;/code&gt; are called for the CFS
and the RT scheduler, respectively. Note that by the &lt;code&gt;for_each_class(class)&lt;/code&gt; loop,
scheduling classes are processed one by one in order of their priority,
by which &lt;code&gt;fair_sched_class&lt;/code&gt; can be taken care of only if there is
nothing to do with the &lt;code&gt;rt_sched_class&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The function &lt;code&gt;__schedule()&lt;/code&gt; is invoked at many places of the kernel,
where there is a need to reschedule threads. One of such cases is after
interrupt handling, since by an interrupt, some thread (&lt;em&gt;e.g.&lt;/em&gt;, a
high-priority RT thread) may need to run immediately. Another case is
when someone calls it explicitly. For example, a system call
&lt;code&gt;sched_yield()&lt;/code&gt; that causes the calling thread to relinquish the CPU is
implemented using &lt;code&gt;__schedule()&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;periodic-accounting-scheduler_tick&#34;&gt;Periodic accounting: &lt;code&gt;scheduler_tick()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The function &lt;code&gt;scheduler_tick()&lt;/code&gt; is periodically called by the kernel
with the frequency &lt;code&gt;HZ&lt;/code&gt;, which is the tick rate of the system timer
defined on system boot.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void scheduler_tick(void)
{
    int cpu = smp_processor_id();
    struct rq *rq = cpu_rq(cpu);
    struct task_struct *curr = rq-&amp;gt;curr;
    ...
    update_rq_clock(rq);
    curr-&amp;gt;sched_class-&amp;gt;task_tick(rq, curr, 0);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing among what &lt;code&gt;scheduler_tick()&lt;/code&gt;
does is updating clocks invoking &lt;code&gt;update_rq_clock()&lt;/code&gt;. The
&lt;code&gt;update_rq_clock()&lt;/code&gt; reads a clock source and updates the &lt;code&gt;clock&lt;/code&gt; of the
run queue, which the scheduler’s time accounting is based on. The second
thing is checking if the current thread is running for too long, and if
it is, setting a flag that indicates that &lt;code&gt;__schedule()&lt;/code&gt; must be called
to replace the running task with another. This done by calling
&lt;code&gt;task_tick&lt;/code&gt; in a scheduler class. Again, actual work is delegated to a
scheduler-class-specific function pointed by this function pointer.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;completely-fair-scheduler-cfs&#34;&gt;Completely Fair Scheduler (CFS)&lt;/h2&gt;

&lt;h3 id=&#34;nice-values-priorities-in-the-cfs&#34;&gt;Nice values: priorities in the CFS&lt;/h3&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://helix979.github.io/jkoo/img/nice.PNG&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Nice-to-weight conversion.&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;The priority managed by the CFS is called the nice value in particular,
which ranges between $-20$ and $19$. Lower values mean higher priorities
(&lt;em&gt;i.e.&lt;/em&gt;, $-20$ for the highest priority and $19$ for the lowest
priority). The default nice value is $0$ unless otherwise inherited from
a parent process. Each nice value has a corresponding weight value,
which predefined as Figure 5. Note that there is an
inverse relationship between weight values and nice values. The weight
value determines how large proportion of CPU time a thread gets compared
to other threads. Refer to “time slice&amp;rdquo; for more detail.&lt;/p&gt;

&lt;h3 id=&#34;time-slice&#34;&gt;Time slice&lt;/h3&gt;

&lt;p&gt;The CFS sets what is called a time slice that is an interval for which a
thread is allowed to run without being preempted. The time slice for a
thread is proportional to the weight of the thread divided by the total
weight of all threads in a run queue. Therefore, the thread that has a
relatively high priority is likely to run longer than the other ready
threads.&lt;/p&gt;

&lt;p&gt;The function &lt;code&gt;__scheduler_tick&lt;/code&gt; that is periodically called by a timer
interrupt invokes &lt;code&gt;task_tick&lt;/code&gt; of the scheduling class of the current
thread. In the CFS, this function pointer eventually executes the
function &lt;code&gt;check_preempt_tick()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr)
{
    ...
    ideal_runtime = sched_slice(cfs_rq, curr);
    delta_exec = curr-&amp;gt;sum_exec_runtime - curr-&amp;gt;prev_sum_exec_runtime;
    if (delta_exec &amp;gt; ideal_runtime) {
        resched_task(rq_of(cfs_rq)-&amp;gt;curr);
        ...
        return;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;check_preempt_tick()&lt;/code&gt; is responsible for checking if the current
thread is running any longer than its time slice. If that is the case,
&lt;code&gt;check_preempt_tick()&lt;/code&gt; calls &lt;code&gt;resched_task()&lt;/code&gt; that marks that
&lt;code&gt;__schedule()&lt;/code&gt; should be executed now to change the running thread. The
function &lt;code&gt;sched_slice()&lt;/code&gt; is the one that calculates the time slice for
the currently running thread.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)
{
    u64 slice = __sched_period(cfs_rq-&amp;gt;nr_running + !se-&amp;gt;on_rq);
    ...
    cfs_rq = cfs_rq_of(se);
    load = &amp;amp;cfs_rq-&amp;gt;load;
    ...
    slice = calc_delta_mine(slice, se-&amp;gt;load.weight, load);
    ...
    return slice;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Linux kernel sets a scheduling period during which all ready threads
are guaranteed to run at least once. The function &lt;code&gt;__sched_period&lt;/code&gt;
updates the scheduling period considering the number of ready threads.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static u64 __sched_period(unsigned long nr_running)
{
    u64 period = sysctl_sched_latency;
    unsigned long nr_latency = sched_nr_latency;
    if (unlikely(nr_running &amp;gt; nr_latency)) {
        period = sysctl_sched_min_granularity;
        period *= nr_running;
    }
    return period;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default, the kernel targets to
serve &lt;code&gt;sched_nr_latency&lt;/code&gt; threads for &lt;code&gt;sysctl_sched_latency&lt;/code&gt; ms, assuming
that a thread is supposed to run at a time for at least
&lt;code&gt;sysctl_min_granularity&lt;/code&gt; ms, which is defined as follows:&lt;/p&gt;

&lt;p&gt;$$
\mbox{sysctl_min_granularity}=\frac{\mbox{sysctl_sched_latency}}{\mbox{sched_nr_latency}}
$$&lt;/p&gt;

&lt;p&gt;That is, the default scheduling period is &lt;code&gt;sysctl_sched_latency&lt;/code&gt; ms.
However, if there are more than &lt;code&gt;sched_nr_latency&lt;/code&gt; threads in a run
queue, the scheduling period is set to &lt;code&gt;sysctl_min_granularity&lt;/code&gt; ms
multiplied by the number of ready threads.&lt;/p&gt;

&lt;p&gt;The updated scheduling period is scaled by the function
&lt;code&gt;calc_delta_mine()&lt;/code&gt; that finalizes the time slice for the currently
running thread in the following way:&lt;/p&gt;

&lt;p&gt;$$
\mbox{time slice of the current thread} \\&lt;br /&gt;
= (\mbox{scheduling period}) * \left(\frac{\mbox{weight of the current thread}}{\mbox{sum of the weights of all threads}}\right).
$$&lt;/p&gt;

&lt;h3 id=&#34;virtual-runtime&#34;&gt;Virtual runtime&lt;/h3&gt;

&lt;p&gt;Time accounting in the CFS is done by using the so-called virtual
runtime. For a given thread, its virtual runtime is defined as follows:&lt;/p&gt;

&lt;p&gt;$$
\mbox{virtual runtime} = (\mbox{actual runtime}) * 1024 / \mbox{weight}.
$$&lt;/p&gt;

&lt;p&gt;Since a weight is proportional to a priority, the virtual runtime of a
high priority thread goes slower than that of a low priority thread,
when the actual runtime is the same. Note that in the above, $1024$ is
the weight value for the nice $0$. Thus, the virtual runtime for the
thread of nice $0$ is equal to its actual runtime.&lt;/p&gt;

&lt;p&gt;All updates to the virtual runtime are performed in &lt;code&gt;update_curr()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void update_curr(struct cfs_rq *cfs_rq)
{
    struct sched_entity *curr = cfs_rq-&amp;gt;curr;
    u64 now = rq_of(cfs_rq)-&amp;gt;clock_task;
    unsigned long delta_exec;
    ...
    delta_exec = (unsigned long)(now - curr-&amp;gt;exec_start);
    ...
    __update_curr(cfs_rq, curr, delta_exec);
    curr-&amp;gt;exec_start = now;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;clock_task&lt;/code&gt; is used to get a timestamp &lt;code&gt;now&lt;/code&gt; at the moment when
&lt;code&gt;update_curr()&lt;/code&gt; is invoked. The &lt;code&gt;clock_task&lt;/code&gt; returns &lt;code&gt;rq-&amp;gt;clock&lt;/code&gt; minus
time stolen by handling IRQs. &lt;code&gt;curr-&amp;gt;exec_start&lt;/code&gt; holds the timestamp
that was made when the current thread updated its virtual runtime most
recently. Thus, the difference between &lt;code&gt;now&lt;/code&gt; and &lt;code&gt;curr-&amp;gt;exec_start&lt;/code&gt; is
the actual runtime elapsed since the last update to the virtual runtime
of the current thread. This actual time increment is fed into
&lt;code&gt;__update_curr()&lt;/code&gt; where conversion to virtual time increment is done by &lt;code&gt;calc_delta_fair()&lt;/code&gt; below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void
__update_curr(struct cfs_rq *cfs_rq, struct sched_entity *curr,
          unsigned long delta_exec)
{
    ...
    delta_exec_weighted = calc_delta_fair(delta_exec, curr);
    curr-&amp;gt;vruntime += delta_exec_weighted;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;putting-a-running-thread-back-into-a-runqueue&#34;&gt;Putting a running thread back into a runqueue&lt;/h3&gt;

&lt;p&gt;In order to change the running thread, the previously-running thread
should be first back into a runqueue. For this matter, the CFS uses
&lt;code&gt;put_prev_task_fair()&lt;/code&gt; that in turn calls &lt;code&gt;put_prev_entity()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void put_prev_entity(struct cfs_rq *cfs_rq, struct sched_entity *prev)
{
    if (prev-&amp;gt;on_rq)
        update_curr(cfs_rq);
    ...
    if (prev-&amp;gt;on_rq) {
        ...
        __enqueue_entity(cfs_rq, prev);
        ...
    }
    cfs_rq-&amp;gt;curr = NULL;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using &lt;code&gt;prev-&amp;gt;on_rq&lt;/code&gt;, the &lt;code&gt;put_prev_entity()&lt;/code&gt; checks if the thread is
already on a run queue, in which case nothing should be done. Otherwise,
the running thread needs to update its virtual runtime and enqueue into
the &lt;code&gt;cfs_rq&lt;/code&gt;. The &lt;code&gt;cfs_rq&lt;/code&gt; is implemented with a red-black (RB) tree,
where threads are sorted according to their virtual runtime.&lt;/p&gt;

&lt;h3 id=&#34;choosing-the-thread-to-run-next&#34;&gt;Choosing the thread to run next&lt;/h3&gt;

&lt;p&gt;Choosing the next thread to run in the CFS is the business of
&lt;code&gt;pick_next_task_fair()&lt;/code&gt;, whose main body is implemented by a sub-routine
&lt;code&gt;pick_next_entity()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static struct sched_entity *pick_next_entity(struct cfs_rq *cfs_rq)
{
    struct sched_entity *se = __pick_first_entity(cfs_rq);
    struct sched_entity *left = se;
    if (cfs_rq-&amp;gt;skip == se) {
        struct sched_entity *second = __pick_next_entity(se);
        if (second &amp;amp;&amp;amp; wakeup_preempt_entity(second, left) &amp;lt; 1)
            se = second;
    }
    if (cfs_rq-&amp;gt;last &amp;amp;&amp;amp; wakeup_preempt_entity(cfs_rq-&amp;gt;last, left) &amp;lt; 1)
        se = cfs_rq-&amp;gt;last;

    if (cfs_rq-&amp;gt;next &amp;amp;&amp;amp; wakeup_preempt_entity(cfs_rq-&amp;gt;next, left) &amp;lt; 1)
        se = cfs_rq-&amp;gt;next;
    ...
    return se;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, &lt;code&gt;wakeup_preempt_entity()&lt;/code&gt; is the means to
balance fairness in terms of virtual time among threads. Specifically,
what &lt;code&gt;wakeup_preempt_entity(se1, se2)&lt;/code&gt; does is to compare the virtual
times of &lt;code&gt;se1&lt;/code&gt; and &lt;code&gt;se2&lt;/code&gt;, and return $-1$ if &lt;code&gt;se1&lt;/code&gt; has run shorter than
&lt;code&gt;se2&lt;/code&gt;, $0$ if &lt;code&gt;se1&lt;/code&gt; has long than &lt;code&gt;se2&lt;/code&gt; but not long enough, and $1$ if
thread 1 has run long enough. Keeping things fair between threads using
this function, the thread to run next is picked in the following order.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Pick the thread that has the smallest virtual runtime.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pick the “next&amp;rdquo; thread that woke last but failed to preempt on
wake-up, since it may need to run in a hurry.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pick the “last&amp;rdquo; thread that ran last for cache locality.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Do not run the “skip&amp;rdquo; process, if something else is available.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;real-time-rt-scheduler&#34;&gt;Real-Time (RT) Scheduler&lt;/h2&gt;

&lt;h3 id=&#34;the-run-queue-of-the-rt-scheduler&#34;&gt;The run queue of the RT scheduler&lt;/h3&gt;

&lt;p&gt;The RT scheduler’s run queue, represented by &lt;code&gt;struct rt_rq&lt;/code&gt;, is mainly
implemented with an array, each element of which is the head of a linked
list that manages the threads of a particular priority.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct rt_prio_array {
    DECLARE_BITMAP(bitmap, MAX_RT_PRIO+1);
    struct list_head queue[MAX_RT_PRIO];
};

struct rt_rq {
    struct rt_prio_array active;
    ...
    int curr;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All real-time threads whose priority is &lt;code&gt;x&lt;/code&gt; are inserted into a linked list headed by
&lt;code&gt;active.queue[x]&lt;/code&gt;. When there exists at least one thread in
&lt;code&gt;active.queue[x]&lt;/code&gt;, the &lt;code&gt;x&lt;/code&gt;-th bit of &lt;code&gt;active.bitmap&lt;/code&gt; is set.&lt;/p&gt;

&lt;h3 id=&#34;execution-and-scheduling-polices&#34;&gt;Execution and scheduling polices&lt;/h3&gt;

&lt;p&gt;A newly queued thread is always placed at the end of each list of a
corresponding priority in the run queue. The first task on the list of
the highest priority available is taken out to run.&lt;/p&gt;

&lt;p&gt;There are two scheduling polices applied for the RT scheduler, which are
&lt;code&gt;SCHED_FIFO&lt;/code&gt; and &lt;code&gt;SCHED_RR&lt;/code&gt;. The difference between the two becomes
distinct in &lt;code&gt;task_tick_rt()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void task_tick_rt(struct rq *rq, struct task_struct *p, int queued)
{
    struct sched_rt_entity *rt_se = &amp;amp;p-&amp;gt;rt;

    update_curr_rt(rq);

    watchdog(rq, p);

    /*
     * RR tasks need a special form of timeslice management.
     * FIFO tasks have no timeslices.
     */
    if (p-&amp;gt;policy != SCHED_RR)
        return;

    if (--p-&amp;gt;rt.time_slice)
        return;

    p-&amp;gt;rt.time_slice = sched_rr_timeslice;

    /*
     * Requeue to the end of queue if we (and all of our ancestors) are the
     * only element on the queue
     */
    for_each_sched_rt_entity(rt_se) {
        if (rt_se-&amp;gt;run_list.prev != rt_se-&amp;gt;run_list.next) {
            requeue_task_rt(rq, p, 0);
            set_tsk_need_resched(p);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The threads with &lt;code&gt;SCHED_FIFO&lt;/code&gt; can run until they stop or yield. There is
nothing to be done every tick interrupt. The &lt;code&gt;SCHED_RR&lt;/code&gt; threads are
given a time slice, which is decremented by 1 on the tick interrupt.
When this time slice becomes zero, &lt;code&gt;SCHED_RR&lt;/code&gt; threads are enqueued
again.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
