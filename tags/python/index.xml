<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Jinkyu Koo</title>
    <link>https://helix979.github.io/jkoo/tags/python/index.xml</link>
    <description>Recent content in Python on Jinkyu Koo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Jinkyu Koo</copyright>
    <atom:link href="/jkoo/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Python in half an hour</title>
      <link>https://helix979.github.io/jkoo/post/python-tutorial/</link>
      <pubDate>Sun, 29 Nov 2015 11:00:00 +0000</pubDate>
      
      <guid>https://helix979.github.io/jkoo/post/python-tutorial/</guid>
      <description>

&lt;p&gt;In what follows in this tutorial, the result of a statement is expressed
in the form of &lt;code&gt;#result#&lt;/code&gt;, unless otherwise mentioned.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Basic arithmetic operations&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Comments start with a hash sign (#).

1 + 2   # Addition 
1 / 2   #0# Division
1 / 2.  #0.5# If either one of the numbers in a division is a float,
        #     so does the result.
3 % 2   #1# Modulus
2 ** 3  #8# Power. Equivalent to pow(2,3).
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Variables&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# A valid name of a variable is an alpha-numeric string
# consisting of one or more letters, digits or underscore characters,
# just like in C.

x = 3           # Assignment
x + 1           #4#
x = None        # None is is a built-in constant
                # that represents the absence of a value.
x, y = 1, 2     # Multiple assignments at a time
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Import modules&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import math
math.sqrt(4)

# If you do not want to write the module name each time you call the function
from math import *
sqrt(4)

# If you are sure that you only need sqrt() in the math module
from math import sqrt
sqrt(4)

# Module alias
import math as m
m.sqrt(4)

# Function alias
from math import sqrt as sq
sq(4)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Strings&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Strings can be expressed with double quotes (&amp;quot;) or single quotes (&#39;).
# There is no difference bettwen double quotes and single quotes.
x = &amp;quot;abc&amp;quot;
x = &#39;abc&#39;   # Exactly the same as above
y = &amp;quot;ab&#39;cd&#39;ef&amp;quot;  # &#39;cd&#39; is part of the string.
z = &#39;ab&amp;quot;cd&amp;quot;ef&#39;  # &amp;quot;cd&amp;quot; is part of the string. The strings y and z are not the same.

# String formatting
# Use C-like conversion specifiers.
&#39;test %s %d %.1f&#39; % (&#39;abc&#39;, 10, 10.33)   #&#39;test abc 10 10.3&#39;#

# String methods
&#39;  /sys/fs  &#39;.strip()    #&#39;/sys/fs&#39;# Remove whitespaces on the left and the right.
&#39;/sys/fs&#39;.split(&#39;/&#39;)     #[&#39;&#39;, &#39;sys&#39;, &#39;fs&#39;]#
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Lists&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Lists start with [ and end with ].
# Elements are separated by a comma (,).
x = [1, 2, 3]

# A list can hold different types of elements.
y = [1, 2, &amp;quot;abc&amp;quot;, [5,6]]

# List methods
z = [&#39;b&#39;, &#39;a&#39;]
z.append(&#39;c&#39;)   #[&#39;b&#39;,&#39;a&#39;,&#39;c&#39;]#
z.index(&#39;b&#39;)    #0# Returns the index of the first occurrence of a value
z.sort()        #[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]#
z.remove(&#39;a&#39;)   # Removes the element that appears first.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tuples&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Tuples start with ( and end with ).
# Tuples are just like lists with an exception that they cannot be changed.
x = (1, 2)

# Values separated by commas automatically becomes a tuple.
x = 1, 2    # The same as above.

# A tuple with a single element
x = (1,)    # Here the comma is important. (1) is just 1. 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sequence commons: strings, lists, and tuples are called sequences.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = &#39;123&#39;
y = [1, 2, 3]
z = (1, 2, 3)

# Sequences can be indexed as follows:
x[0]        #&#39;1&#39;#
y[0:2]      #[1,2]# Returns a list with elements such that 0&amp;lt;=index&amp;lt;2.
z[1:]       #(2,3)# Return a tuple with elements such that 1&amp;lt;=index.
x[:2]       #&#39;12&#39;# Returns a string with elements such that index&amp;lt;2. 
y[-1]       #3# Returns the last element.
z[-2]       #2# Returns the second last element.
y[:]        #[1, 2, 3]# Returns a list with all elements.

# Addition and multiplication for sequences
# Two objects of the same type can be added.
x + &#39;4&#39;     #&#39;1234&#39;#
y + [4, 5]  #[1, 2, 3, 4, 5]#
z + (4,)    #(1, 2, 3, 4)#

# Multiplication can be understood as multiple additions.
y*3         #[1, 2, 3, 1, 2, 3, 1, 2, 3]# Regard it as y+y+y.

# Pairing elements of two sequences
x = [1, 2, 3]
y = [4, 5, 6]
zip(x, y)   #[(1, 4), (2, 5), (3, 6)]#

# * operator: argument unpacking
z = [x, y]
zip(*z)     #[(1, 4), (2, 5), (3, 6)]# The same as zip(x,y)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Dictionaries&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# A dictionary starts with { and ends with },
# and it is like a hash table that maps a key to a value.

# An element is defined as a pair of a key and a value.
d = {&#39;key1&#39;:&#39;value1&#39;, &#39;key2&#39;:&#39;value2&#39;}
d = {}                  # An empty dictionary
d[&#39;key3&#39;] = &#39;value3&#39;    # Adds a key-value pair.
d[&#39;key3&#39;]               #&#39;value3&#39;# Returns a value for the key

# The key must be immutable.
d[&#39;abc&#39;] = 3        # OK
d[(a,b)] = [1,2]    # OK
d[3] = &#39;abc&#39;        # OK
d[[1,2,3]] = 2      # Not OK, since a list is mutable.

# Dictionary methods
d.get(key)      # Returns a value corresponding to the key.
d.has_key(key)  # Returns True if the key in the dictionary, and False otherwise.
d.items()       # Returns a list of (key, value) tuple pairs.
d.keys()        # Returns a list of keys.
d.values()      # Returns a list of values.
d.copy()        # Return a dictionary object that
                # has exactly the same contents as d.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Print to screen&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Note that what is shown here valid in Python 2.7 only.
# Syntax for print is quite changed in Python 3.4.
x = 1
y = [1,2]
print 3                 #3#
print 3, &amp;quot;abc&amp;quot;          #3 abc#
print &amp;quot;%d %d&amp;quot; % (3, 4)  #3 4#
print x,                #1# Trailing comma suppresses newline.
print str(y)            #[1, 2]# str() transforms an object into a string.
print repr(y)           #[1, 2]# 
                        # Most of times, repr() results in the same as str().
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Assignment is by reference!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# One thing to remember
# when you assign a list or a dictionary (i.e., mutable objects) to another variable:
# Assignment is always by reference, not by copy.
x = [1, 2, 3]
y = x           # Here, y get a reference to what x points to, i.e., [1, 2, 3]
y[0] = 4
x               #[4, 2, 3]# Note that x is changed by y.

# To copy a list
y = x[:]        # Creates a new list that contains all elements of x.
y[0] = 4
x               #[1 ,2 ,3]#

# To copy a dictionary
x = {1: 1}
y = x
z = x.copy()    # Use the copy() method.
y[1] = 2
z[1] = 3
print str(x), str(y), str(z)    #{1: 2} {1: 2} {1: 3}#
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conditionals&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if x == 5:          # Note that there is a colon (:) at the end.
    # VERY IMPORTANT:
    # All statements in a block must be indented by the same amount.
    # Otherwise, you will see an error.
    x += 1
    y = x + 2
    print x, y
elif x in [4,5,6]:  # True if x is one of 4, 5, or 6.
    if x != 2:      # Conditions can be nested.
        print x
else:
    # Empty blocks are not allowed.
    # Put &#39;pass&#39; for a placeholder when you want do nothing.
    pass            
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The for-loops&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = [1, 2, 3]
for v in x:         # Iterates the elements of x from the first to the last.
    print v,        #1 2 3#

range(3)            #[0, 1, 2]# Returns a list of integers from 0 to 3-1.
range(1,4)          #[1, 2, 3]# Returns a list of integers from 1 to 4-1.

for i in range(3):
    print x[i],     #1 2 3#
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The while-loops&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = 5
while x &amp;gt; 0:
    x -= 1
    if x == 3:
        continue    # continue as in C
    if x == 1:
        break       # break as in C
    print x,        #4 2#
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List comprehension: making a list from other list&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = [i*2 for i in range(5)]
y = [i*2 for i in range(5) if i%2 == 0]
x       #[0, 2, 4, 6, 8]#
y       #[0, 4, 8]#
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Iterating over a dictionary&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;d = {1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;}
for k, v in d.items():
    print str(k) + &#39;:&#39; + v,   #1:a 2:b 3:c#

# The following is the same as above.
key = d.keys()
value = d.values()
for k, v in zip(key, value):
    print str(k) + &#39;:&#39; + v,   #1:a 2:b 3:c#
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Functions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Writing your own functions
def foo(arg1):      # Do not forget the colon at the end.
    x = arg1 + 1
    return x        # You can omit the return statement
                    # if there is nothing to return.

def bar(arg1, arg2 = 3):    # arg2 gets its value as 3 by default.
    x = arg2 + 1
    return arg1[0], x       # Here, arg1 can be of any type except
                            # a literal constant.

q, w = bar(&#39;abc&#39;)       # You can omit the argument that has its default value.
print q, w              #a 4#
print bar(&#39;abc&#39;)        #(&#39;a&#39;, 4)# arg1 is a string.
print bar(&#39;abc&#39;, 4)     #(&#39;a&#39;, 5)# Put something to change the default value.
print bar([1, 2])       #(1, 4)# arg1 is a list.
print bar((5, 6))       #(5, 4)# arg1 is a tuple.
print bar(7)            # An error

# Make use of argument unpacking operator (*).
x = (1, 2)
def add(a, b):
    return a+b

print add(*x)              #3# Just add(x) will cause an error.

# A function can have a different name.
my_add = add
my_add(1,2)                #3#

# Lambda expressions
add2 = lambda arg1, arg2: arg1+arg2
add2(1,2)                  #3#

# Lambda expressions may be used when you pass an argument that is a function.
a = [(4,2),(1,3)]
sorted(a, key=lambda x:x[0])    #[(1, 3), (4, 2)]#
                                # Sort by the first element of tuples
sorted(a, key=lambda x:x[1])    #[(4, 2), (1, 3)]#
                                # Sort by the second element of tuples

# To change global variables within a function
x = 1
def foo(a):
    global x        # Without this, x won&#39;t be changed.
    x += a
    return
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Exceptions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# If something bad happens within a try block, an exception is raised.
def foo(x):
    y = 1
    try:                        
        y = y/x
    except ZeroDivisionError:   # You can specify the type of
                                # an exception to deal with.
        print &amp;quot;divided by zero&amp;quot;
    except:                     # All exceptions other than
                                # the above are handled here.
        print &amp;quot;something else&amp;quot;

foo(0)                          #divided by zero#
foo(&#39;1&#39;)                        #something else#

# Raise exceptions and catch exception objects.
import traceback                    # To use print_exc()
try:
    raise Exception(&amp;quot;my exception&amp;quot;) # Raise an exception with some argument.
except Exception as e:              # The &#39;Exception&#39; is the base of all exception
                                    # objects, so it can catch all exceptions.
    if e.args == (&amp;quot;my exception&amp;quot;,): # You can check what argument is in.
        print &amp;quot;my exception occurs&amp;quot;
    print e.args[0]                 #my exception#
                                    # Print the argument of the exception.
    # Print exception information by which you can locate the culprit.
    traceback.print_exc()           

# The else-clause: executed when there is no problem in the try block.
while True:
    default = &#39;1&#39;
    menu = 1
    try:
        # Take an input from a user
        # Just typing the enter key will cause the default value to be chosen.
        t = raw_input(&amp;quot;Enter a number (default=&amp;quot;+default+&amp;quot;): &amp;quot;) or default
        menu = int(t) % 10
        print &#39;You selected &#39; + str(menu)
    except:
        print &#39;Invalid input&#39;    # e.g., character inputs will come to here.
    else:           
        break       # Executed if no exceptions are raised in the try block.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Reading from and writing to a file&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fr = open(&#39;text.txt&#39;, &#39;r&#39;)      # Open text.txt to read.
fw = open(&#39;result.txt&#39;, &#39;w&#39;)    # Open result.txt to write.
for line in fr.readlines():     # Iterate text.txt line by line.
    fw.write(line + &#39; some&#39;)    # Write a string as a a line
fr.close()                      # Do not forget to close files
fw.close()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Some useful built-in functions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = [1, 0, 2]
len(x)              #3# Returns a length of a sequence.
max(x)              #2$ Returns the largest element.
min(x)              #0# Returns the smallest element.
sorted(x)           # Returns a list of sorted elements of a sequence.
sum(x)              #3# Returns the sum of all elements.

# The &#39;in&#39; operator returns True if a value is in a sequence and False otherwise.
2 in x              #True# 

# To delete an element of a list or a dictionary
del x[1]            # Here, 1 is an index.

d = {1:2, 3:4}
del d[1]            # Here, 1 is a key.

# Convert a string or a number to an integer or an floating number.
int(&#39;12&#39;)           #12#
int(12.3)           #12# 
float(&amp;quot;3.3&amp;quot;)        #3.3#
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;drawing-a-graph&#34;&gt;Drawing a graph&lt;/h1&gt;

&lt;p&gt;You may need to additionally install numpy and matplotlib modules to
plot a graph. In Ubuntu, the easiest way to get them is to type:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ sudo apt-get install python-numpy python-matplotlib&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import numpy as np
import matplotlib.pyplot as plt

x1 = [1, 4, 8]
y1 = [0.5, 2, 4]

x2 = [1, 2, 3]
x2_array = np.array(x2)     # np.array() makes an array object.
y2_array = x2_array ** 2    # The array object enables
                            # MATLAB-like element-wise operations

# plt.plot() takes lists or arrays as its data arguments.
plt.plot(x1, y1, x2_array, y2_array)

# The following commands are self-explanatory.
plt.title(&#39;title&#39;)
plt.xlabel(&#39;label for x-axis&#39;)
plt.ylabel(&#39;label for y-axis&#39;, fontsize=15)
plt.grid()
plt.legend([&#39;x/2&#39;, &#39;pow(x,2)&#39;])
plt.xlim(0, 9)
plt.ylim(0, 10)
plt.savefig(&#39;fig1.png&#39;, format=&#39;png&#39;)   # Try pdf, eps, ... almost all you can imagine.


# Whenever you want another figure
plt.figure()    

plt.subplot(211)
plt.plot(x1, y1, &#39;r--&#39;)

plt.subplot(212)
plt.plot(x2_array, y2_array, &#39;b.&#39;, markersize=30)
plt.xlim(0, 4)
plt.ylim(0, 10)

plt.savefig(&#39;fig2.png&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;redirect-a-text-stream-to-your-python-script&#34;&gt;Redirect a text stream to your Python script&lt;/h1&gt;

&lt;p&gt;Sometimes you may want to process the output of Linux commands within
Python scripts by redirecting. Use the following example script in such
a case. Say you write the codes in &lt;code&gt;find_keyword.py&lt;/code&gt; and you want to
catch the lines that contain ‘kworker’ from /proc/kmsg. Then, type:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ sudo cat /proc/kmsg | python find_keyword.py kworker file1.txt&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import sys

if (len(sys.argv) != 3):
    print &#39;\n Usage example:&#39;
    print &#39; When you want to find lines from /proc/kmsg that contain &amp;quot;kworker&amp;quot;,&#39;
    print &#39; print them to screen, and store them into file1.txt,&#39;
    print &#39; sudo cat /proc/kmsg | python &#39;+sys.argv[0]+&#39; kworker file1.txt\n&#39;
    sys.exit(1)

fo = open(sys.argv[2], &amp;quot;w&amp;quot;)

while True:
    try:
        line = sys.stdin.readline() # Reads a line from stdin
    except KeyboardInterrupt:       # until a user hits ctrl+c
        break

    if not line:                    # or until there is nothing left to read
        break

    if sys.argv[1] in line:
        print line
        fo.write(line + &#39;\n&#39;)

fo.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;regular-expressions&#34;&gt;Regular expressions&lt;/h1&gt;

&lt;p&gt;A regular expression specifies a set of strings that matches it. You may
have to spend non-trivial time to be familiar with all pattern syntaxes
of regular expressions. Here, we show just a few of use cases. For more
detail, refer to:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;https://docs.python.org/2/library/re.html&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import re

text1 = &#39;Fig. 1: initially there are 60 points in each class.&#39;
text2 = &#39;My phone number is 123-456-7890.&#39;
text3 = &#39;MemFree:           50116 kB&#39;
lines = [text1, text2, text3]

# See if text1 contains &#39;where&#39;.
m1 = re.search(&#39;where&#39;, text1, flags=0)
print repr(m1)   #None#
if m1:           # None is equivalent to False in a condition.
    print &amp;quot;This won&#39;n be printed.&amp;quot;


# See if text1 is a string that contains &#39;there&#39; somewhere in it.
m2 = re.search(&#39;.*there.*&#39;, text1, flags=0)    
# &#39;.*&#39; means any character of 0 or more occurrences.

if m2:            # If matched, m2 is not None.
    # m2.group() is the whole string that matches the pattern &#39;.*there.*&#39;.
    print m2.group()    


# Use parentheses for grouping
m3 = re.search(r&#39;.*([A-Z]).*there.*\s(\d+).*&#39;, text1, flags=0)
# Why &#39;r&#39; before the opening quote? Check raw strings!
# Without the &#39;r&#39;, all backslashes must be twice-typed.
# To avoid confusion, patterns in Python code are
# usually expressed in raw string notation.
# &#39;[A-Z]&#39; means an alphabet between A and Z,
# &#39;\s&#39; a white space, and
# &#39;\d+&#39; a digit of 1 or more occurrences.

if m3:
    print m3.group()      
    print m3.group(1)   #F# The string captured within the first parentheses.
    print m3.group(2)   #60# The string captured within the second parentheses.


# See if text2 contains a phone number
m4 = re.search(r&#39;\d{3}-\d{3}-\d{4}&#39;, text2, flags=0)
if m4:
    print m4.group()    #123-456-7890#


# Parse the number that corresponds to Memfree from a list of strings.
for line in lines:
    m5 = re.search(r&#39;MemFree:\s+(\d+)\s+kB&#39;, line, flags=0)
    if m5:
        print m5.group(1)    #50116#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;classes&#34;&gt;Classes&lt;/h1&gt;

&lt;p&gt;Python provides all the standard features of object oriented programming
by classes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Person:
    # Class variables defined in this way
    # are shared by all instances,
    # like static member variables in C++.
    cnt = 0       

    # The initializer method, like a constructor in C++.
    def __init__(self, name_):
        # Class variables defined in this way
        # are unique to each instance.
        self.name = name_

        # Access like a static member variable in C++.
        Person.cnt += 1

    # Class methods
    def showCount(self):
        print &amp;quot;The number of Persons are %d.&amp;quot; % (Person.cnt)

    def showName(self):
        print &amp;quot;My name is %s.&amp;quot; % (self.name)


# Creating instances
p1 = Person(&#39;James&#39;)
p2 = Person(&#39;Matt&#39;)
p1.showName()       #My name is James.#
p2.showName()       #My name is Matt.#
p1.showCount()      #The number of Persons are 2.#

# Class members are normally all public in C++ terminology.
print Person.cnt, p1.name, p2.name      #2 James Matt#


# Add or remove attributes of class instances.
p1.age = 10
del p1.age


# Inheritance
class Student(Person):  # Inherits from Persion
    def __init__(self, name_, grade_):
        self.grade = grade_
        Person.__init__(self, name_)
    def showGrade(self):
        print &amp;quot;Hmm.. My grade is %s.&amp;quot; % (self.grade)

    # All methods in Python are virtual in C++ terminology:
    # Derived classes override methods of the same name defined in their base classes.
    def showName(self):
        # This is how to extend rather than simply replace
        # the base class method of the same name.
        Person.showName(self)
        print &#39;And I am a student.&#39;

s = Student(&#39;Aaron&#39;, &#39;A+&#39;)
s.showName()        #My name is Aaron.\nAnd I am a student.#
s.showGrade()       #Hmm.. My grade is A+.#
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
